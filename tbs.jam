
import virtual-target ;
import sequence ;
import path ;
import set ;
import string ;

import regex ;
import testing ;
import feature : feature ;
import project ;


ME = [ modules.binding $(__name__) ] ;
TBS = $(ME:D) ;

echo "TBS" $(TBS) ;
include [ path.join $(TBS) project-config.jam ] ;

rule normalizePath ( myvar )
{
  if [ modules.peek : OS ] = "NT" 
  {
     myvar = [ path.make-NT $(myvar:T) ] ; 
  }
  return $(myvar) ;
}

rule libs-decl ( group ? : names + ) 
{ 
	local requirements ;
	for name in $(names) 
	{ 
		lib $(name) : : <name>$(name) <link>shared ;
		requirements += <library>$(name) ;
	}

	if $(group) != "" { alias $(group) : : : : $(requirements) ; }
	
}

# Name target using at sign (@) and add '<tag>@tbs.dot-from-at' requirement
rule dot-from-at ( name : type ? : property-set )
{
	original-name = [ virtual-target.add-prefix-and-suffix $(name) : $(type) : $(property-set) ] ;
	return [ regex.replace  $(original-name) "@" "."  ] ;
}

rule link-test ( shared-object )
{
	test-name = [ string.join "link-test-" $(shared-object) ] ;
	exe $(test-name) : $(shared-object) $(TBS)/Link_Test//main : <tag>@tbs.dot-from-at ;
}

rule plugin ( name : sources + : requirements * )
{
	requirements += <use>$(TBS)//Plugin ;
	requirements += <tag>@tbs.dot-from-at ;
	requirements += <library>$(TBS)/TSeries_Utils//TSeries@Utils/<link>shared ;
  requirements += <library>$(TBS)/TBS//TBS/<link>shared ;

	lib $(name) : $(sources) : $(requirements) ;
	tbs.link-test $(name) ;
}

# Build object files from list of sources
rule obj-build ( name : root : source-list + : requirements * )
{
  localroot = [ normalizePath $(root) ] ; 
	for local source in $(source-list)
	{
		source_rel = [ path.relative $(source) $(localroot) ] ;
		obj $(source_rel:S=) : $(source) : $(requirements) ;
	}
	
	alias $(name) : [ obj-list $(root) : $(source-list) ] ;
}

# Return list of targets generated by obj-build
rule obj-list ( root : source-list + )
{
	local obj-list ;
  localroot = [ normalizePath $(root) ] ; 
	for local source in $(source-list)
	{
		source_rel = [ path.relative $(source) $(localroot) ] ;
		obj-list += $(source_rel:S=) ;
	}
	return $(obj-list) ;
}


#______________________________________________________________________________
#
# Rules for installation to directories known to package creation scripts
# Artifact is target name
# location is directory relative to a TBS_INSTALL_DIR constant
# The TBS_INSTALL_DIR constant must be defined in project-config.jam
#________

rule installation ( alias ? : artifact : location )
{
	if $(TBS_INSTALL_DIR) = ""
	{
		ECHO "warning: TBS_INSTALL_DIR not specified." ;
		ECHO "warning: specify it in your ~/user-config.jam" ;
	}

	if $(alias) = ""
	{
		alias = "installation" ;
	}

	local location_lin = [ path.join $(TBS_INSTALL_DIR) lin $(location) ] ;
	local location_win = [ path.join $(TBS_INSTALL_DIR) win $(location) ] ;
	local location_tpro = [ path.join $(TBS_INSTALL_DIR) tpro $(location) ] ;
	local location_lindevice = [ path.join $(TBS_INSTALL_DIR) lindevice $(location) ] ;
	local location_linpc = [ path.join $(TBS_INSTALL_DIR) linpc $(location) ] ;

	install $(alias)
		: $(artifact)
		:
			<device>lin:<location>$(location_lin)
			<device>win:<location>$(location_win)
			<device>tpro:<location>$(location_tpro)
			<device>lindevice:<location>$(location_lindevice)
			<device>linpc:<location>$(location_linpc)
		;
}

#______________________________________________________________________________
#
# Rules for installation to directories known to eclipse
#________

rule eclipse-integration ( rulesuffix ? : artifact : location )
{
	local rulename ;
	if $(rulesuffix) = ""
	{
		rulename = eclipse-integration ;
	}
	else
	{
		rulename = eclipse-integration.$(rulesuffix) ;
	}

	install $(rulename) 
		:
			$(artifact)
		:
			<device>lin:<location>$(location).lin
			<device>tpro:<location>$(location).tpro
			<device>lindevice:<location>$(location).lindevice
			<device>linpc:<location>$(location).linpc
			<device>win:<location>$(location).win
		;
}

rule eclipse-integration-group ( rulesuffixes + )
{
	local group-names ;
	for suffix in $(rulesuffixes)
	{
		group-names += eclipse-integration.$(suffix) ;
	}

	alias eclipse-integration : $(group-names) ;
}


#______________________________________________________________________________
#
# All code below is taken from newer versions of boost build 
# We need it for compatibility with older versions (on dulik)
#________

rule glob-tree ( roots * : patterns + : exclude-patterns * )
{
	return [ sequence.transform path.make : [ .glob-tree
		[ sequence.transform path.native : $(roots) ]
		: $(patterns)
		: $(exclude-patterns)
		] ] ;
}

local rule .glob-tree ( roots * : patterns * : exclude-patterns * )
{
	local excluded ;
	if $(exclude-patterns)
	{
		excluded = [ GLOB $(roots) : $(exclude-patterns) ] ;
	}
	local result = [ set.difference [ GLOB $(roots) : $(patterns) ] : $(excluded) ] ;
	local subdirs ;
	for local d in [ set.difference [ GLOB $(roots) : * ] : $(excluded) ]
	{
		if ! ( $(d:D=) in . .. ) && ! [ CHECK_IF_FILE $(d) ] { subdirs += $(d) ; }
	}
	if $(subdirs)
	{
		result += [ .glob-tree $(subdirs) : $(patterns) : $(exclude-patterns) ] ;
	}
	return $(result) ;
}
