//
// AsyncCommand.h
//
// $Id: //poco/svn/Foundation/include/Poco/AsyncCommand.h#2 $
//
// Library: Foundation
// Package: AsyncIO
// Module:  AsyncCommand
//
// Definition of the AsyncCommand class and subclasses.
//
// Copyright (c) 2007, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#ifndef DeviceIO_AsyncCommand_INCLUDED
#define DeviceIO_AsyncCommand_INCLUDED


#include "Poco/DeviceIO/DeviceIO.h"
#include "Poco/RefCountedObject.h"
#include "Poco/AutoPtr.h"
#include "Poco/Event.h"
#include "Poco/BasicEvent.h"
#include "Poco/DeviceIO/AsyncEvent.h"
#include "Poco/Exception.h"
#include <ios>


namespace Poco {
namespace DeviceIO {


class AsyncChannel;


class DeviceIO_API AsyncCommand: public RefCountedObject
	/// AsyncCommand is the base class for all asynchronous input/output
	/// commands used with AsyncChannel.
	///
	/// See class AsyncChannel for more information about asynchronous input/output.
{
public:
	typedef AutoPtr<AsyncCommand> Ptr;
	
	enum State
	{
		CMD_PENDING,     /// Command is queued for execution.
		CMD_IN_PROGRESS, /// Command is currently being executed.
		CMD_COMPLETED,   /// Command has completed successfully.
		CMD_FAILED       /// Command has failed.
	};
	
	BasicEvent<AsyncEvent> commandCompleted;
		/// Fired when the command has successfully completed.
		
	BasicEvent<AsyncEvent> commandFailed;
		/// Fired when the command has failed.
	
	State state() const;
		/// Returns the current state of the command.
	
	void wait();
		/// Waits for the completion of the command.
	
	void wait(long milliseconds);
		/// Waits at most the given timeout for the 
		/// completion of the command. Throws a
		/// TimeoutException if the command does
		/// not complete within the given timeout.
		
	bool tryWait(long milliseconds);
		/// Waits at most the given timeout for the 
		/// completion of the command. 
		///
		/// Returns true if the command completes within
		/// the given timeout, otherwise false.
		
	bool succeeded() const;
		/// Returns true iff the command completed successfully.
		
	bool failed() const;
		/// Returns true iff the command has completed with an error.
		
	const Exception* exception() const;
		/// If the command failed with an exception, returns a
		/// clone of the exception. Otherwise, returns a null pointer.
		
	int execute(AsyncChannel& channel);
		/// Executes the command on the given AsyncChannel.
		///
		/// Sets the state to CMD_IN_PROGRESS, calls
		/// executeImpl(), and, according to its result,
		/// sets the state to CMD_COMPLETED or CMD_FAILED
		/// and signals the event.
		///
		/// Returns the number of bytes processed by the
		/// command.
		
	int result() const;
		/// Returns the result of the command.
		
protected:
	AsyncCommand();
		/// Creates the AsyncCommand.
		
	~AsyncCommand();
		/// Destroys the AsyncCommand.
	
	virtual int executeImpl(AsyncChannel& channel) = 0;
		/// Executes the command on the given AsyncChannel.
		/// Must be overridded by subclasses.
		///
		/// Returns the number of bytes processed by the
		/// command.

private:
	State _state;
	Event _completed;
	int _result;
	Exception* _pException;
};


class DeviceIO_API AsyncWriteCommand: public AsyncCommand
	/// An asynchronous write command.
{
public:
	AsyncWriteCommand(const void* buffer, int length);
		/// Create an AsyncWriteCommand for writing length bytes
		/// from the given buffer. The given buffer must be
		/// valid until the command completes.

	const void* buffer() const;
		/// Returns the buffer's address.
		
	int length() const;
		/// Returns the buffer's size.

protected:
	int executeImpl(AsyncChannel& channel);
	~AsyncWriteCommand();
	
private:
	AsyncWriteCommand();
	
	const void* _buffer;
	int _length;
};


class DeviceIO_API AsyncBufferedWriteCommand: public AsyncWriteCommand
	/// An asynchronous write command. The difference to
	/// AsyncWriteCommand is that AsyncBufferedWriteCommand 
	/// copies the data in the buffer into an internal buffer, thus
	/// the given buffer can be deleted as soon as the constructor
	/// returns.
{
public:
	AsyncBufferedWriteCommand(const void* buffer, int length);
		/// Create an AsyncBufferedWriteCommand for writing length bytes
		/// from the given buffer and copies the data from the
		/// given buffer into an internal buffer.
		///
		/// The internal buffer can be accessed via the buffer()
		/// member function inherited from AsyncWriteCommand.

protected:
	~AsyncBufferedWriteCommand();
};


class DeviceIO_API AsyncReadCommand: public AsyncCommand
	/// An asynchronous read command.
{
public:
	AsyncReadCommand(void* buffer, int length);
		/// Create an AsyncReadCommand for reading up to length
		/// bytes into the given buffer.

	void* buffer() const;
		/// Returns the buffer's address.
		
	int length() const;
		/// Returns the buffer's size.

protected:
	int executeImpl(AsyncChannel& channel);
	~AsyncReadCommand();
	
private:
	AsyncReadCommand();
	
	void* _buffer;
	int _length;
};


class DeviceIO_API AsyncBufferedReadCommand: public AsyncReadCommand
	/// An asynchronous read command. In contrast to
	/// AsyncReadCommand, which requires an externally supplied
	/// buffer that must be valid until the command completes,
	/// AsyncBufferedReadCommand maintains an internal buffer.
{
public:
	AsyncBufferedReadCommand(int length);
		/// Create an AsyncReadCommand for reading up to length
		/// bytes into an internal buffer.
		///
		/// The buffer can be accessed via the buffer() member
		/// function inherited from AsyncReadCommand.

protected:
	~AsyncBufferedReadCommand();
};


class DeviceIO_API AsyncSeekCommand: public AsyncCommand
	/// An asynchronous seek command.
{
public:
	AsyncSeekCommand(std::streamoff off, std::ios::seekdir dir = std::ios::beg);
		/// Creates an AsyncSeekCommand for setting the current read/write position.

protected:
	int executeImpl(AsyncChannel& channel);
	~AsyncSeekCommand();
	
private:
	AsyncSeekCommand();
	
	std::streamoff _off;
	std::ios::seekdir _dir;
};


//
// inlines
//
inline AsyncCommand::State AsyncCommand::state() const
{
	return _state;
}


inline int AsyncCommand::result() const
{
	return _result;
}


inline const Exception* AsyncCommand::exception() const
{
	return _pException;
}


inline bool AsyncCommand::succeeded() const
{
	return _state == CMD_COMPLETED;
}


inline bool AsyncCommand::failed() const
{
	return _state == CMD_FAILED;
}


inline const void* AsyncWriteCommand::buffer() const
{
	return _buffer;
}


inline int AsyncWriteCommand::length() const
{
	return _length;
}


inline void* AsyncReadCommand::buffer() const
{
	return _buffer;
}


inline int AsyncReadCommand::length() const
{
	return _length;
}


} } // namespace Poco::DeviceIO


#endif // DeviceIO_AsyncCommand_INCLUDED
