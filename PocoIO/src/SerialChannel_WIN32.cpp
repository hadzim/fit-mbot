//
// SerialChannel_WIN32.cpp
//
// $Id: //poco/Main/DeviceIO/Serial/src/SerialChannel_WIN32.cpp#1 $
//
// Library: Serial
// Package: Serial
// Module:  SerialChannel_WIN32
//
// Copyright (c) 2008, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include "Poco/DeviceIO/SerialChannel_WIN32.h"
#include "Poco/Exception.h"
#include <windows.h>
#include <cstring>

#include <iostream>

using Poco::CreateFileException;
using Poco::IOException;

namespace Poco {
namespace DeviceIO {
namespace Serial {

SerialChannelImpl::SerialChannelImpl(SerialConfigImpl* pConfig) :
		_pConfig(pConfig, true) {
}

SerialChannelImpl::~SerialChannelImpl() {
}

void SerialChannelImpl::initImpl() {
	std::cout << "init impl" << std::endl;
	/*
	 if (!SetCommState(_handle, &(_pConfig->dcb()))) handleError(_pConfig->name());

	 if (!SetCommTimeouts(_handle, &(_pConfig->commTimeouts()))) handleError(_pConfig->name());

	 DWORD bufSize = (DWORD) _pConfig->getBufferSizeImpl();
	 SetupComm(_handle, bufSize, bufSize);
	 */
	std::cout << "init impl done" << std::endl;
}

void SerialChannelImpl::openImpl() {
	std::cout << "open impl" << std::endl;
	//_handle = CreateFileA(_pConfig->name().c_str(), GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	_handle = CreateFileA(_pConfig->name().c_str(),
			GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
			FILE_FLAG_OVERLAPPED, 0);
	if (INVALID_HANDLE_VALUE == _handle)
		handleError(_pConfig->name());

	initImpl();

	std::cout << "open impl done " << _handle << std::endl;
}

void SerialChannelImpl::closeImpl() {
	if (!CloseHandle(_handle))
		handleError(_pConfig->name());
}

int SerialChannelImpl::readImpl(char* pBuffer, int length) {
	std::cout << "read impl" << std::endl;
	/*
	DWORD read = 0;
	DWORD readCount = 0;
	ZeroMemory(pBuffer, length);
	do {
		if (!ReadFile(_handle, pBuffer + readCount, length - readCount, &read,
				NULL))
			handleError(_pConfig->name());
		else if (0 == read)
			break;

		poco_assert(read <= length - readCount);
		readCount += read;
	} while (readCount < length);

	return readCount;*/

	DWORD dwRead = 0;
	BOOL fWaitingOnRead = FALSE;
	OVERLAPPED osReader = {0};

	// Create the overlapped event. Must be closed before exiting
	// to avoid a handle leak.
	osReader.hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);

	if (osReader.hEvent == NULL){
		throw IOException("Error reading from " + _pConfig->name());
	}
	   // Error creating overlapped event; abort.

	if (!fWaitingOnRead) {
	   // Issue read operation.
	   if (!ReadFile(_handle, pBuffer, length, &dwRead, &osReader)) {
	      if (GetLastError() != ERROR_IO_PENDING){     // read not delayed?
	         // Error in communications; report it.
	    	  throw IOException("Error reading from " + _pConfig->name());
	      } else {
	         fWaitingOnRead = TRUE;
	      }
	   }
	   else {
		   std::cout << "read bytes: " << dwRead << std::endl;
		   return dwRead;
	      // read completed immediately
	      //HandleASuccessfulReadA(pBuffer, dwRead);
	    }
	}
	std::cout << "read bytes: " << dwRead << std::endl;
	return dwRead;
}

int SerialChannelImpl::readImpl(char*& pBuffer) {
	std::cout << "read impl 2" << std::endl;
	if (!_pConfig->getUseEOFImpl())
		throw InvalidAccessException();

	int bufSize = _pConfig->getBufferSizeImpl();
	int it = 1;

	if ((0 == bufSize) || (0 != pBuffer))
		throw InvalidArgumentException();

	std::string buffer;
	DWORD read = 0;
	DWORD readCount = 0;

	pBuffer = static_cast<char*>(std::calloc(bufSize, sizeof(char))); //! freed in parent call

	do {
		if (_leftOver.size()) {
			read = _leftOver.size() > bufSize - readCount ?
					bufSize - readCount : _leftOver.size();
			std::memcpy(pBuffer + readCount, _leftOver.data(), read);
			if (read == _leftOver.size())
				_leftOver.clear();
			else
				_leftOver.assign(_leftOver, read, _leftOver.size() - read);
		} else {
			if (!ReadFile(_handle, pBuffer + readCount, bufSize - readCount,
					&read, NULL))
				handleError(_pConfig->name());
			else if (0 == read)
				break;
		}

		poco_assert(read <= bufSize - readCount);

		buffer.assign(static_cast<char*>(pBuffer + readCount), read);
		size_t pos = buffer.find(_pConfig->getEOFCharImpl());
		if (pos != buffer.npos) {
			readCount += static_cast<DWORD>(pos);
			PurgeComm(_handle, PURGE_RXCLEAR);
			_leftOver.assign(buffer, pos + 1, buffer.size() - pos - 1);
			break;
		}

		readCount += read;
		if (readCount >= bufSize) {
			bufSize *= ++it;
			pBuffer = static_cast<char*>(std::realloc(pBuffer,
					bufSize * sizeof(char)));
		}
	} while (true);

	return readCount;
}

int SerialChannelImpl::writeImpl(const char* buffer, int length) {
	/*
	 std::cout << "write " << length << " to handle " << _handle << "length = " << length << std::endl;
	 DWORD written = 0;

	 int val = WriteFile(_handle, buffer, length, &written, NULL);
	 std::cout << "write val" << val << " written: " << written << std::endl;
	 if (!val || ((written != length) && (0 != written))){
	 std::cout << "write error " << std::endl;
	 handleError(_pConfig->name());
	 } else if (0 == written){
	 throw IOException("Error writing to " + _pConfig->name());
	 }

	 return written;*/

	OVERLAPPED osWrite = { 0 };
	DWORD dwWritten = 0;
	DWORD dwRes;
	BOOL fRes;

	// Create this write operation's OVERLAPPED structure's hEvent.
	osWrite.hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
	if (osWrite.hEvent == NULL){
		// error creating overlapped event handle
		throw IOException("Error writing to " + _pConfig->name());
	}

	// Issue write.
	if (!WriteFile(_handle, buffer, length, &dwWritten, &osWrite)) {
		if (GetLastError() != ERROR_IO_PENDING) {
			// WriteFile failed, but isn't delayed. Report error and abort.
			fRes = FALSE;
		} else
			// Write is pending.
			dwRes = WaitForSingleObject(osWrite.hEvent, INFINITE);
		switch (dwRes) {
		// OVERLAPPED structure's event has been signaled.
		case WAIT_OBJECT_0:
			if (!GetOverlappedResult(_handle, &osWrite, &dwWritten, FALSE))
				fRes = FALSE;
			else
				// Write operation completed successfully.
				fRes = TRUE;
			break;

		default:
			// An error has occurred in WaitForSingleObject.
			// This usually indicates a problem with the
			// OVERLAPPED structure's event handle.
			fRes = FALSE;
			break;
		}
	} else {
		// WriteFile completed immediately.
		fRes = TRUE;
	}
	CloseHandle(osWrite.hEvent);
	//return fRes;
	if (!fRes) {
		throw IOException("Error writing to " + _pConfig->name());
	}
	std::cout << "write bytes: " << dwWritten << std::endl;
	return dwWritten;
}

const std::string& SerialChannelImpl::getNameImpl() const {
	return _pConfig->name();
}

std::string& SerialChannelImpl::getErrorText(DWORD errCode, std::string& buf) {
	DWORD dwRet;
	LPSTR pTemp = NULL;

	dwRet = FormatMessageA(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM
					| FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL, errCode,
			LANG_USER_DEFAULT, (LPSTR) &pTemp, 0, NULL);

	if (dwRet && pTemp) {
		std::size_t len = std::string(pTemp).length() - 2;
		if (len >= 0) {
			pTemp[len] = '\0';  //remove cr and newline character
			buf = pTemp;
		}

		LocalFree((HLOCAL) pTemp);
	}

	return buf;
}

void SerialChannelImpl::handleError(const std::string& name) {
	std::string errorText;
	DWORD error = GetLastError();

	switch (error) {
	case ERROR_FILE_NOT_FOUND:
		throw FileNotFoundException(name, getErrorText(error, errorText));
	case ERROR_ACCESS_DENIED:
		throw FileAccessDeniedException(name, getErrorText(error, errorText));
	case ERROR_ALREADY_EXISTS:
	case ERROR_FILE_EXISTS:
		throw FileExistsException(name, getErrorText(error, errorText));
	case ERROR_FILE_READ_ONLY:
		throw FileReadOnlyException(name, getErrorText(error, errorText));
	case ERROR_CANNOT_MAKE:
	case ERROR_INVALID_NAME:
	case ERROR_FILENAME_EXCED_RANGE:
		throw CreateFileException(name, getErrorText(error, errorText));
	case ERROR_BROKEN_PIPE:
	case ERROR_INVALID_USER_BUFFER:
	case ERROR_INSUFFICIENT_BUFFER:
		throw IOException(name, getErrorText(error, errorText));
	case ERROR_NOT_ENOUGH_MEMORY:
		throw OutOfMemoryException(name, getErrorText(error, errorText));
	case ERROR_HANDLE_EOF:
		break;
	default:
		throw FileException(name, getErrorText(error, errorText));
	}
}

}
}
} // namespace Poco::DeviceIO::Serial
